<html>  <head>    <title>TTT XOnD</title>    <style>canvas { width: 100%; height: 100% }</style>  </head><body><script src="lib/three.js"></script><script src="lib/OrbitControls.js"></script><script src="lib/coffee-script.js"></script><script type="text/coffeescript">
#blue vs green

#constants and globals
 
myDistance = 1300  
myCamera = 0
myScene = 0
myRenderer = 0 
myControls = 0 

playerColor = [
	0x00FF00
	0x0000FF
	]
playerNames = [
	"green",
	"blue"]
selectedCubeMaterials = [ 
	new THREE.MeshLambertMaterial( {transparent: true, opacity: 0.8, ambient: playerColor[0], color: playerColor[0], diffuse: 0} ),
	new THREE.MeshLambertMaterial( {transparent: true, opacity: 0.8, ambient: playerColor[1], color: playerColor[1], diffuse: 0} )
	]
winCubeMaterial = new THREE.MeshLambertMaterial( {transparent: true, opacity: 0.8, ambient: 0xeedd00, color: 0xeedd00, diffuse: 0} ) 

playersTotal = 2
	
selectedCubeMaterial = new THREE.MeshLambertMaterial( {transparent: true, opacity: 0.8, ambient: 0x0000DD, color: 0x0000DD, diffuse: 0} )

#those are the glorious cubes we are seeing on the screen 
myCubes = []	

#all visible objects are here to help ray casting on them 
mySceneObjects = []

#all cubes in an unselected state. We store them so that we could go back to them fast
myStartCubes = [] 

#current selection
myCubeSelection = [1,1,1]
 

#playing on a field of a size 3. In future, this can be changed
myFieldSize = 3

#how sparse are cubes in space
mySparsity = 400
 
	
myTurnCounter = 0
myGameInProgress = true
 
dirs4p =[[[0,0,0,0],[0,0,0,0]],[[0,0,0,1],[0,0,0,-1]],[[0,0,0,-1],[0,0,0,1]],[[0,0,1,0],[0,0,-1,0]],[[0,0,1,1],[0,0,-1,-1]],[[0,0,1,-1],[0,0,-1,1]],[[0,0,-1,0],[0,0,1,0]],[[0,0,-1,1],[0,0,1,-1]],[[0,0,-1,-1],[0,0,1,1]],[[0,1,0,0],[0,-1,0,0]],[[0,1,0,1],[0,-1,0,-1]],[[0,1,0,-1],[0,-1,0,1]],[[0,1,1,0],[0,-1,-1,0]],[[0,1,1,1],[0,-1,-1,-1]],[[0,1,1,-1],[0,-1,-1,1]],[[0,1,-1,0],[0,-1,1,0]],[[0,
1,-1,1],[0,-1,1,-1]],[[0,1,-1,-1],[0,-1,1,1]],[[0,-1,0,0],[0,1,0,0]],[[0,-1,0,1],[0,1,0,-1]],[[0,-1,0,-1],[0,1,0,1]],[[0,-1,1,0],[0,1,-1,0]],[[0,-1,1,1],[0,1,-1,-1]],[[0,-1,1,-1],[0,1,-1,1]],[[0,-1,-1,0],[0,1,1,0]],[[0,-1,-1,1],[0,1,1,-1]],[[0,-1,-1,-1],[0,1,1,1]],[[1,0,0,0],[-1,0,0,0]],[[1,0,0,1],[-1,0,0,-1]],[[1,0,0,-1],[-1,0,0,1]],[[1,0,1,0],[-1,0,-1,0]],[[1,0,1,1],[-1,0,-1,-1]]
,[[1,0,1,-1],[-1,0,-1,1]],[[1,0,-1,0],[-1,0,1,0]],[[1,0,-1,1],[-1,0,1,-1]],[[1,0,-1,-1],[-1,0,1,1]],[[1,1,0,0],[-1,-1,0,0]],[[1,1,0,1],[-1,-1,0,-1]],[[1,1,0,-1],[-1,-1,0,1]],[[1,1,1,0],[-1,-1,-1,0]],[[1,1,1,1],[-1,-1,-1,-1]],[[1,1,1,-1],[-1,-1,-1,1]],[[1,1,-1,0],[-1,-1,1,0]],[[1,1,-1,1],[-1,-1,1,-1]],[[1,1,-1,-1],[-1,-1,1,1]],[[1,-1,0,0],[-1,1,0,0]],[[1,-1,0,1],[-1,1,0,-1]],[[1,-1,
0,-1],[-1,1,0,1]],[[1,-1,1,0],[-1,1,-1,0]],[[1,-1,1,1],[-1,1,-1,-1]],[[1,-1,1,-1],[-1,1,-1,1]],[[1,-1,-1,0],[-1,1,1,0]],[[1,-1,-1,1],[-1,1,1,-1]],[[1,-1,-1,-1],[-1,1,1,1]],[[-1,0,0,0],[1,0,0,0]],[[-1,0,0,1],[1,0,0,-1]],[[-1,0,0,-1],[1,0,0,1]],[[-1,0,1,0],[1,0,-1,0]],[[-1,0,1,1],[1,0,-1,-1]],[[-1,0,1,-1],[1,0,-1,1]],[[-1,0,-1,0],[1,0,1,0]],[[-1,0,-1,1],[1,0,1,-1]],[[-1,0,-1,-1],[1,0
,1,1]],[[-1,1,0,0],[1,-1,0,0]],[[-1,1,0,1],[1,-1,0,-1]],[[-1,1,0,-1],[1,-1,0,1]],[[-1,1,1,0],[1,-1,-1,0]],[[-1,1,1,1],[1,-1,-1,-1]],[[-1,1,1,-1],[1,-1,-1,1]],[[-1,1,-1,0],[1,-1,1,0]],[[-1,1,-1,1],[1,-1,1,-1]],[[-1,1,-1,-1],[1,-1,1,1]],[[-1,-1,0,0],[1,1,0,0]],[[-1,-1,0,1],[1,1,0,-1]],[[-1,-1,0,-1],[1,1,0,1]],[[-1,-1,1,0],[1,1,-1,0]],[[-1,-1,1,1],[1,1,-1,-1]],[[-1,-1,1,-1],[1,1,-1,1]
],[[-1,-1,-1,0],[1,1,1,0]],[[-1,-1,-1,1],[1,1,1,-1]],[[-1,-1,-1,-1],[1,1,1,1]]]                                                                                                                                                            

dirs3p = [[[0,0,1],[0,0,-1]],[[0,0,-1],[0,0,1]],[[0,1,0],[0,-1,0]],[[0,1,1],[0,-1,-1]],[[0,1,-1],[0,-1,1]],[[0,-1,0],[0,1,0]],[[0,-1,1],[0,1,-1]],[[0,-1,-1],[0,1,1]],[[1,0,0],[-1,0,0]
],[[1,0,1],[-1,0,-1]],[[1,0,-1],[-1,0,1]],[[1,1,0],[-1,-1,0]],[[1,1,1],[-1,-1,-1]],[[1,1,-1],[-1,-1,1]],[[1,-1,0],[-1,1,0]],[[1,-1,1],[-1,1,-1]],[[1,-1,-1],[-1,1,1]],[[-1,0,0],[1,0,0]],[[-1,0,
1],[1,0,-1]],[[-1,0,-1],[1,0,1]],[[-1,1,0],[1,-1,0]],[[-1,1,1],[1,-1,-1]],[[-1,1,-1],[1,-1,1]],[[-1,-1,0],[1,1,0]],[[-1,-1,1],[1,1,-1]],[[-1,-1,-1],[1,1,1]]]                                   
checkWins3 = (field, x,y,z,dim ) ->
	playerc = field[x][y][z]
	if playerc == -1 
		return null
	for dirpair in dirs3p
		counter = -1
		startpos = [x,y,z]
		winpositions = []
		for dir in dirpair
			pos = startpos
			while field[pos[0]][pos[1]][pos[2]] == playerc && counter < 3
				winpositions.push pos
				counter += 1
				pos = vadd( pos,dir )			
				if ! pos.every( (x) -> 0 <= x <= 2 )
					break
		if counter >= 3
			return winpositions
	return null

checkWins3 = (field, x,y,z,k,dim ) ->
	playerc = field[x][y][z]
	if playerc == -1 
		return null
	for dirpair in dirs3p
		counter = -1
		startpos = [x,y,z]
		winpositions = []
		for dir in dirpair
			pos = startpos
			while field[pos[0]][pos[1]][pos[2]] == playerc && counter < 3
				winpositions.push pos
				counter += 1
				pos = vadd( pos,dir )			
				if ! pos.every( (x) -> 0 <= x <= 2 )
					break
		if counter >= 3
			return winpositions
	return null				 

isPlayersTurn = (player_id) -> currentPlayer() == player_id
currentPlayer = () -> myTurnCounter % playersTotal

myBattlefield = 0

initializeBattlefield = (dim) -> 
	initializeArrayRecursive( [], dim, dim, -1)
	
initializeArrayRecursive = (array, dim, counter, value) ->
	if (counter == 0) 
		return value
	array = new Array(dim)
	for i in [0.. (dim-1)]
		array[i] = initializeArrayRecursive( array, dim, counter-1, value)
		
isFree = ([x,y,z]) -> myBattlefield[x][y][z] == -1
occupy = ([x,y,z]) -> myBattlefield[x][y][z] = currentPlayer()

	
turn = ([x,y,z]) ->  
	if (isFree([x,y,z]))  
		occupy([x,y,z]) 
		markCube( currentPlayer(), x,y,z)
		winpath = checkWins3(myBattlefield, x,y,z, myFieldSize) 
		if (winpath != null) 
			myGameInProgress = false
			return winpath
	else
		return null
	

nextTurn = () ->
	myTurnCounter += 1
 
createCube = (dim, x,y,z, pcolor= 0xff0000) ->
	geometry =  new THREE.CubeGeometry( dim, dim, dim ) 
	cube = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {wireframe: true, transparent: true, opacity: 0.8, ambient: pcolor, color: pcolor, diffuse: 0} ) )
	cube.position = { x , y , z }  
	mySceneObjects.push cube 
	return cube
	

vadd = (s1, s2) ->
	out = []
	for i in [0.. (s1.length-1)]
			out[i] = s1[i] + s2[i]
	return out

vsub = (s1, s2) ->
	out = []
	for i in [0.. (s1.length-1)]
			out[i] = s1[i] - s2[i]
	return out
	
smul = (s1,con) ->
	return s1.map( (x) -> x*con )
		
 
markCube = (player_id, x,y,z) ->
	myCubes[x][y][z].material = selectedCubeMaterials[player_id]
clearCube = (x,y,z) ->
	myCubes[x][y][z].material = myStartCubes[x][y][z].material
 	 
initCubes = (scene) ->
	color = 0xff0000
	cubes = []
	ranges = [-mySparsity, 0, mySparsity]
	for x in ranges
		slice = []
		for y in ranges
			col = []
			for z in ranges
				cube = createCube( 100, x,	y, z, color )  
				scene.add cube
				col.push cube 
			slice.push col
		color += 0x004400
		cubes.push slice  
	return cubes
		 
initScene = () ->
	scene = new THREE.Scene() 
	scene.add( new THREE.AmbientLight(0xeeeeee))
	myStartCubes = initCubes(scene)
	myCubes = initCubes(scene) 
	scene.fog = new THREE.FogExp2( 0xdddddd , 0.0005 );
	plane = new THREE.Mesh(
		new THREE.PlaneGeometry((mySparsity*2 + 100), (mySparsity*2 + 50)), new THREE.MeshLambertMaterial({wireframe: false, transparent: true, opacity: 0.9, ambient: 0x1111ee, color: 0x1111ee, diffuse: 0} ));
	plane.position.z = -( mySparsity + 200)
	scene.add(plane)
	return scene 



setupCamera = () ->
	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 )
	camera.position.z = myDistance
	return camera 
	
setupRenderer = () -> 
	renderer = new THREE.WebGLRenderer()
	renderer.setSize( window.innerWidth, window.innerHeight )
	document.body.appendChild( renderer.domElement )
	renderer.setClearColor(0xdddddd,1)	
	return renderer
	
setupControls = (cam) ->
	controls = new THREE.OrbitControls( cam );
	controls.addEventListener( 'change', render );
	return controls
	

initGame = () ->
	console.debug "init game"
	myBattlefield = initializeBattlefield(myFieldSize)  
	 
 
	
render = () -> 
	myRenderer.render( myScene, myCamera )
init = () -> 
	myCamera = setupCamera() 
	myScene = initScene() 
	myRenderer = setupRenderer()
	myControls = setupControls(myCamera)
		
animate = () -> 
	requestAnimationFrame( animate ) 
	render()
	myControls.update() 
window.onload = -> start()

start = () -> 
	init()
	initGame() 
	animate()
 


gameTurn = (idx) ->
	if (myGameInProgress)
		winpath = turn( idx ) 
		if winpath!= null
			nextTurn()
		return winpath
	else
		alert "Player #{playerNames[currentPlayer()]} won!" 
		return null	
document.ondblclick  = (event) ->	 
	vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5)
	projector = new THREE.Projector()
	projector.unprojectVector(vector, myCamera)

	raycaster = new THREE.Raycaster(myCamera.position, vector.sub(myCamera.position).normalize())
	intersects = raycaster.intersectObjects(mySceneObjects)
			
	getCubeIndex = (intersections, arr ) ->   
		for x in [0.. (arr.length-1) ] 
			for y in [0.. (arr[x].length-1) ] 
				for z in [0.. (arr[x][y].length-1) ]  
					for o in intersections  
						if  arr[x][y][z]  == o.object
							return [x,y,z] 
		return null 
	alert getCubeIndex( intersects, myCubes )	
	if (intersects.length > 0)   
		idx = getCubeIndex( intersects, myCubes )  
		winpath = (idx) 
		if (winpath is not null)
			for e in winpath  
					myCubes[e[0]][e[1]][e[2]].material = winCubeMaterial 
		

window.onresize = () ->
	myCamera.aspect = window.innerWidth / window.innerHeight
	myCamera.updateProjectionMatrix()
	myRenderer.setSize( window.innerWidth, window.innerHeight )
	
	
</script>
	
</body>
</html>
